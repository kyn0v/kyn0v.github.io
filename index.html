<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Kyno&#39;s Blog🐱‍🏍</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Kyno&#39;s Blog🐱‍🏍">
<meta property="og:url" content="https://kyno.me/index.html">
<meta property="og:site_name" content="Kyno&#39;s Blog🐱‍🏍">
<meta property="og:description" content="个人博客">
<meta property="og:locale">
<meta property="article:author" content="Kyno Yang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Kyno's Blog🐱‍🏍" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kyno&#39;s Blog🐱‍🏍</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">棉纺厂原住民，东纺幼儿园毕业生</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://kyno.me"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Writing-Blog-in-GitPage" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/05/Writing-Blog-in-GitPage/" class="article-date">
  <time class="dt-published" datetime="2021-02-05T16:00:00.000Z" itemprop="datePublished">2021-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/05/Writing-Blog-in-GitPage/">Blog in GitPage</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>通过GitPage搭建博客多次，每次都有新感觉（大雾）。  </p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><ol>
<li>将网站的静态页面文件和博客构建源码文件分开提交，如何解决？</li>
<li>如何配置个人域名？  </li>
</ol>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><h2 id="针对博客部署问题"><a href="#针对博客部署问题" class="headerlink" title="针对博客部署问题"></a>针对博客部署问题</h2><h3 id="方案一：双仓库"><a href="#方案一：双仓库" class="headerlink" title="方案一：双仓库"></a><del>方案一：双仓库</del></h3><ol>
<li>建立两个仓库：blogname.github.io和blogsource，分别存放博客静态页面和博客搭建源码。  </li>
<li>本地与之对应建立两个目录并与远程仓库关联。  </li>
<li>实际操作时，在blogsource目录中执行hexo基本操作，生成博客后，将public文件夹中的内容拷贝到本地的blogname.github.io仓库中，最后将两个目录都同步到远程仓库。<br>这种方法容易理解，但是写完博客后的拷贝工作是繁琐的事，于是想到了下面这个方法。  </li>
</ol>
<h3 id="方案二：双仓库改进版"><a href="#方案二：双仓库改进版" class="headerlink" title="方案二：双仓库改进版"></a><del>方案二：双仓库改进版</del></h3><ol>
<li>考虑到每次生成的博客静态页面都是在public目录下，将public\目录关联到远程仓库blogname.github.io，方案一中的本地静态页面仓库可以弃用了。  </li>
<li>每次生成静态页面后，先将blogsource\提交到远端仓库，再进入public\目录把它也提交到与之对应的远端仓库，这样就不用再来回拷贝静态页面文件了。  </li>
</ol>
<h3 id="方案三：双分支（未成功）"><a href="#方案三：双分支（未成功）" class="headerlink" title="方案三：双分支（未成功）"></a><del>方案三：双分支（未成功）</del></h3><ol>
<li>在博客仓库上建立两个分支: master分支与 source 分支，master分支部署静态页面。source分支用以提交博客源码。  </li>
<li>克隆远程博客仓库，本地切换到新建的source分支  </li>
<li>进入新建的临时文件夹，使用hexo init初始化，然后将临时文件夹中的内容拷贝到空博客仓库里,最后将本地仓库提交到远程source分支。至此，博客的source源码分支构建成功  </li>
<li>执行 hexo g 生成静态页面，将仓库中的(.git/ &amp; .gitignore) 拷贝到public\目录里，进入该目录，切换到新建的master分支，将更新提交到远程master分支。至此，博客的master静态页面分支构建成功。<br>但是，这只在博客刚搭建好，第一次提交的时候管用！因为Git的分支是独立的，虽然每次source分支执行hexo g会更新public\目录的内容，但是在切换到master分支后，\publib目录的内容也会随之切换到master版本，也就是未更新版本。即：master分支中的public\的内容不会随着source分支改变其中内容而改变，这也正是Git版本管理的特点之一，所以Git的分支不太适合「子文件夹」这种需求（需要git checkout –orphan master和git submodule结合起来使用，有些麻烦就没有尝试了，另外SVN的分支模型可能更符合这种需求描述）。<br>如果使用这种方法，每次都要：先切换到source分支，拷贝public\中的内容，然后进入public\文件夹，切换到master分支，将刚才拷贝的内容覆盖当前目录（相当麻烦！）。  </li>
</ol>
<h3 id="方案四：双分支-hexo-deployer-git"><a href="#方案四：双分支-hexo-deployer-git" class="headerlink" title="方案四：双分支 + hexo-deployer-git"></a><del>方案四：双分支 + hexo-deployer-git</del></h3><p>沿着方案三的思路，目前的难点在于如何同步public\中的内容，我们可以通过使用hexo-deployer-git插件加以解决。具体步骤如下（对于本地hexo环境的搭建这里不做赘述，注意npm安装时添加<code>--save</code>参数）：  </p>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>在Github上新建一个仓库，命名为username.github.io，不添加README文件，不添加gitignore文件，添加Apache License 2.0。<br>创建完成后，在仓库的设置中设置开启gitpage以及强制https。<br>最后，将仓库克隆到本地。  </p>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>首先，在桌面新建一个临时文件夹blog\，进入文件夹，执行hexo init。修改生成的_config.yml文件的deploy项：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">  type: git   </span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;blogname.github.io  </span><br><span class="line">  branch: master  </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">然后，克隆仓库到本地，进入仓库，切换到新建的source分支：  </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">git checkout -b source  </span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">之后，将blog\中所有内容拷贝到本地仓库中，将更新提交到远程source分支。  </span><br><span class="line">至此，博客源码部署完成。  </span><br><span class="line"></span><br><span class="line">#### 第三步  </span><br><span class="line">确认当前本地仍处于source分支。  </span><br><span class="line">1. 在仓库中执行&#96;hexo g&#96;，生成静态页面  </span><br><span class="line">2. 安装hexo-deployer-git:&#96;npm install hexo-deployer-git --save&#96;  </span><br><span class="line">3. 执行&#96;hexo d&#96;,将静态页面部署到远程仓库的master分支。</span><br><span class="line"></span><br><span class="line">至此，博客静态页面部署完成。  </span><br><span class="line"></span><br><span class="line">#### 第四步  </span><br><span class="line">在上述操作都完成后，把github中远程博客仓库的默认分支改为source，这样以后源码提交时就不用考虑远程切换到source分支了。  </span><br><span class="line"></span><br><span class="line">#### 重新部署  </span><br><span class="line">如果需要在新的机器上重新部署本地环境，需要进行以下步骤：  </span><br><span class="line">1. 配置hexo基本环境（安装Node.js、Git、hexo-deployer-git插件）  </span><br><span class="line">2. 克隆远程仓库  </span><br><span class="line">3. 切换到source分支，安装hexo-deployer-git插件  </span><br><span class="line">4. 执行&#96;hexo new &#39;article&#39;&#96;写文章，写完后push到远程source分支  </span><br><span class="line">5. 执行&#96;hexo g -d&#96;，生成静态页面并推送到远程仓库的master分支  </span><br><span class="line"></span><br><span class="line">### 方案五：双分支 + Travis CI</span><br><span class="line">将CI&#x2F;CD（持续集成和持续部署）应用到GitPage中，可以通过脚本自动部署更新博客，提升任务效率。  </span><br><span class="line">具体步骤根据[官网教程](https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;docs&#x2F;github-pages.html)即可，操作时注意两点：  </span><br><span class="line">1. travis脚本中的分支名注意修改为main</span><br><span class="line">2. &#96;.travis.yml&#96;提交到远端后，CI就会触发，需要时间更新内容，可以在travis-ci官网查看进度</span><br><span class="line">3. 如果 commit 不想让 Travis 构建，那么就在 commit message 里加上ci skip即可:&#96;git commit -m &quot;[ci skip] first commit&quot;</span><br><span class="line">&#96;。</span><br><span class="line"></span><br><span class="line">## 针对域名配置问题</span><br><span class="line"></span><br><span class="line">### 绑定问题  </span><br><span class="line"></span><br><span class="line">对于域名控制台，添加两个Type为CNAME的表项，Host分别填写&#96;@&#96;和&#96;www&#96;，value设置为&#96;xxx.github.io&#96;。CNAME类型使DNS解析时解析为value指定的别名，访问时会发生如下跳转： </span><br></pre></td></tr></table></figure>
<p>xxx.me —&gt; xxx.github.io<br><a target="_blank" rel="noopener" href="http://www.xxx.me/">www.xxx.me</a> —&gt; xxx.github.io</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当然也可以使用A记录，填写测试&#96;ping xxx.github.io&#96;时，显示的ip地址。通常为：</span><br></pre></td></tr></table></figure>
<p>185.199.108.153<br>185.199.109.153<br>185.199.110.153<br>185.199.111.153</p>
<pre><code>对于github仓库，可以在setting中设置`Custom domain`选项，然后更新，最后根据提示重新勾选`Enforce HTTPS`即可。同时，注意在`_config.yml`文件中将`url`项设置为自己的域名。

### 邮箱设置问题
对于个人域名邮箱服务，可以选用腾讯/网易企业邮，墙内使用较为方便。由于腾讯企业邮箱可以与微信互通，因此我选择了腾讯邮箱。具体步骤参考[官网](https://exmail.qq.com/)操作即可。注意一点：在给域名添加解析记录时，要求主机记录不需填写，但域名管理面板上显示此项必填，此时可以通过填写`@`解决。

# Tips  
- `git add -参数`  
    - `git add *`中\*不是Git的一部分,它是一个由shell解释的通配符，该命令意味着添加当前目录中的所有文件，但以点开头的文件除外。  
    - `git add .`在shell中没有特殊的意义，因此Git递归地添加了整个目录，包含了名字以点开头的文件。对仓库的增、改敏感。  
    - `git add -A` 对仓库的增、删、改都敏感。  
    - `git add -u` 对仓库的删、改敏感  
- Git的各分支独立，若要实现子文件夹的管理，最好使用多仓库，不宜使用多分支。或者使用SVN分支管理。  
- 官方文档对于如何实现以及使用的描述更加详细（如[Hexo部署文档](https://hexo.io/zh-cn/docs/deployment)），在有官方文档且能读懂的情况下，官方文档优先，然后再考虑博客文档。
- 完成上述部署步骤后，可能出现页面404的情况，此时在setting页面随意设定一个theme[即可](https://stackoverflow.com/questions/20895543/my-new-github-page-isnt-showing-up)。
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kyno.me/2021/02/05/Writing-Blog-in-GitPage/" data-id="ckkuhxp4900010zt374e740un" data-title="Blog in GitPage" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Learning-DenseBox" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/29/Learning-DenseBox/" class="article-date">
  <time class="dt-published" datetime="2019-08-29T13:08:39.000Z" itemprop="datePublished">2019-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/29/Learning-DenseBox/">DenseBox代码解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>距离上次更新博客又很久了。前段时间照着github上的代码复现了下DenseBox，有所收获记录一下。  </p>
<h1 id="DenseBox代码整体结构"><a href="#DenseBox代码整体结构" class="headerlink" title="DenseBox代码整体结构"></a>DenseBox代码整体结构</h1><ul>
<li>densebox/  <ul>
<li>__init__.py：将文件夹变为一个Python模块  </li>
<li>DenseBox.py：网络结构相关代码  </li>
<li>DenseBoxDataset.py：数据集加载相关代码  </li>
</ul>
</li>
<li>train.py：构建网络-&gt;读取数据-&gt;训练网络  </li>
<li>test.py：构建网络-&gt;读取数据-&gt;测试数据  </li>
</ul>
<h2 id="densebox-init-py解析"><a href="#densebox-init-py解析" class="headerlink" title="densebox/__init__.py解析"></a>densebox/__init__.py解析</h2><p>densebox文件夹下，__init__文件的内容为:  </p>
<pre><code>from .DenseBoxDataset import DenseBoxDataset  
from .DenseBox import DenseBox  
__all__ = [&#39;DenseBoxDataset&#39;, &#39;DenseBox&#39;]  
</code></pre>
<p>这段代码的作用是使得densebox文件夹变为一个模块，换一个角度来说，就是提升了包的导入权限，只要在__all__中声明的内容，可以直接在上一层目录中导入，如train.py文件的开头：  </p>
<pre><code>from densebox import DenseBoxDataset  
from densebox import DenseBox  
</code></pre>
<p>如果使用<code>from densebox import *</code>，则会把注册在__all__列表中的子模块和子包导入到当前作用域中来。  </p>
<h2 id="densebox-DenseBox-py解析"><a href="#densebox-DenseBox-py解析" class="headerlink" title="densebox/DenseBox.py解析"></a>densebox/DenseBox.py解析</h2><p>DenseBox.py用于构建网络结构，首先定义模型结构<code>class DenseBox(torch.nn.Module)</code>，然后实现<code>__init__</code>函数和<code>forward</code>函数。  </p>
<ul>
<li><p>__init__(self, vgg19)  </p>
<p>  __init__函数用于初始化网络结构，它继承父类的__init__函数：<code>super(DenseBox, self).__init__()</code>  </p>
<p>  参数vgg19用于初始化DenseBox初始结构，因为DenseBox的主干网络是基于vgg19的：<code>feats = vgg19.features._modules</code>  </p>
<p>  然后依次添加卷积、池化等网络结构：  </p>
<pre><code># ----------------- Conv1  
self.conv1_1_1 = copy.deepcopy(feats[&#39;0&#39;])  # (0)  
self.conv1_1_2 = copy.deepcopy(feats[&#39;1&#39;])  # (1)  
self.conv1_1 = nn.Sequential(  
    self.conv1_1_1,  
    self.conv1_1_2  
)  # conv_layer1  

#...(中间结构省略)...  

# ----------------- Conv4  
self.conv4_1_1 = copy.deepcopy(feats[&#39;19&#39;])  # (19)  
self.conv4_1_2 = copy.deepcopy(feats[&#39;20&#39;])  # (20)  
self.conv4_1 = nn.Sequential(  
    self.conv4_1_1,  
    self.conv4_1_2  
)  # conv_layer9  

self.conv4_2_1 = copy.deepcopy(feats[&#39;21&#39;])  # (21)  
self.conv4_2_2 = copy.deepcopy(feats[&#39;22&#39;])  # (22)  
self.conv4_2 = nn.Sequential(  
    self.conv4_2_1,  
    self.conv4_2_2  
)  # conv_layer10  

self.conv4_3_1 = copy.deepcopy(feats[&#39;23&#39;])  # (23)  
self.conv4_3_2 = copy.deepcopy(feats[&#39;24&#39;])  # (24)  
self.conv4_3 = nn.Sequential(  
    self.conv4_3_1,  
    self.conv4_3_2  
)  # conv_layer11  

self.conv4_4_1 = copy.deepcopy(feats[&#39;25&#39;])  # (25)  
self.conv4_4_2 = copy.deepcopy(feats[&#39;26&#39;])  # (26)  
self.conv4_4 = nn.Sequential(  
    self.conv4_4_1,  
    self.conv4_4_2  
)  
</code></pre>
<p>  score output结构，输出置信分：  </p>
<pre><code>self.conv5_1_det = nn.Conv2d(in_channels=768,  
                                 out_channels=512,  
                                 kernel_size=(1, 1))  
self.conv5_2_det = nn.Conv2d(in_channels=512,  
                                out_channels=1,  
                                kernel_size=(1, 1))  
torch.nn.init.xavier_normal_(self.conv5_1_det.weight.data)  
torch.nn.init.xavier_normal_(self.conv5_2_det.weight.data)  

self.output_score = nn.Sequential(  
    self.conv5_1_det,  
    nn.Dropout(),  
    self.conv5_2_det  
)  
</code></pre>
<p>  loc output结构，输出bbox偏移量：  </p>
<pre><code>self.conv5_1_loc = nn.Conv2d(in_channels=768,  
                                 out_channels=512,  
                                 kernel_size=(1, 1))  
self.conv5_2_loc = nn.Conv2d(in_channels=512,  
                                out_channels=4,  
                                kernel_size=(1, 1))  
torch.nn.init.xavier_normal_(self.conv5_1_loc.weight.data)  
torch.nn.init.xavier_normal_(self.conv5_2_loc.weight.data)  

self.output_loc = nn.Sequential(  
    self.conv5_1_loc,  
    nn.Dropout(),  
    self.conv5_2_loc  
)  
</code></pre>
</li>
<li><p>forward(self, X)  </p>
<p>  forward函数用于前向传播，输入为图像X，依次通过网络各个结构：  </p>
<pre><code>X = self.conv1_1(X)  
X = self.conv1_2(X)  
X = self.pool1(X)  
#...(省略中间过程)...  
conv4_4_X = self.conv4_4(X)  

# 上采样后与低层特征进行特征融合  
conv4_4_X_us = nn.Upsample(size=(conv3_4_X.size(2),  
                                     conv3_4_X.size(3)),  
                            mode=&#39;bilinear&#39;,  
                            align_corners=True)(conv4_4_X)  
fusion = torch.cat((conv4_4_X_us, conv3_4_X), dim=1)  

#返回结果  
scores = self.output_score(fusion)  
locs = self.output_loc(fusion)  
return scores, locs  
</code></pre>
</li>
</ul>
<h2 id="densebox-DenseBoxDataset-py解析"><a href="#densebox-DenseBoxDataset-py解析" class="headerlink" title="densebox/DenseBoxDataset.py解析"></a>densebox/DenseBoxDataset.py解析</h2><p>DenseBoxDataset.py用于处理读入数据，首先定义自定义数据集<code>class DenseBoxDataset(Dataset)</code>，然后主要实现<code>__init__</code>函数、<code>__getitem__</code>函数和<code>__len__</code>函数。  </p>
<ul>
<li><p>__init__(self, root, ann_file = ‘train.json’, size=(240, 240), test_mode=False)  </p>
<p>  __init__函数用于初始化输入数据（所有图片的annotation），并将其转换到要求的形式读入内存：  </p>
<ol>
<li>首先加载数据集所有图片信息（load_annotations函数）；  </li>
<li>然后从读取的数据中解析出每张图片的annotation信息（get_ann_info函数和_parse_ann_info函数），从annotation中解析出bbox信息和label信息（如果需要，还可以bbox转换到指定的坐标空间），并使用list有序保存。这样每张图片的GT就加载到内存中了；  </li>
<li>最后设置用于“格式化”图片的transform函数。  </li>
</ol>
</li>
<li><p>__getitem__(self, idx)<br>  __getitem__函数，在test阶段只返回图片，在train阶段返回图片以及对应GT。目前我只实现了train阶段的部分：  </p>
<ol>
<li>从__init__中已经初始化的所有图片信息中获得指定idx的图片名，并读取该图片，然后使用__init__中的“格式化”手段变换图片；  </li>
<li>从__init__中已经解析好的bbox信息和label信息中，取得指定idx对应的数据。  </li>
<li>返回图片+GT数据（annotation中解析出的内容）。这里使用的数据集中不含有负样本（没有目标的样本图片）。  </li>
</ol>
</li>
<li><p>__len__(self)<br>  __len__函数返回数据集的大小（图片数量）：<br>  返回__init__中存储所有图片信息的list的长度即可。  </p>
</li>
<li><p>show(img, bboxes):<br>  为了可视化数据加载的是否成功，我编写一个全局函数：  </p>
<pre><code>def show(img, bboxes):  
    &quot;&quot;&quot;  
    img为tensor格式，bbox为list  
    &quot;&quot;&quot;  
    img = np.array(img)  
    img = np.transpose(img,(1,2,0))  
    plt.imshow(img)  
    #画矩形框  
    for bbox in bboxes:  
        xmin = bbox[0]  
        ymin = bbox[1]  
        xmax = bbox[2]  
        ymax = bbox[3]  
        top = ([xmin, xmax], [ymin, ymin])  
        right = ([xmax, xmax], [ymin, ymax])  
        botton = ([xmax, xmin], [ymax, ymax])  
        left = ([xmin, xmin], [ymax, ymin])  
        lines = [top, right, botton, left]  
        for line in lines:  
            plt.plot(*line, color = &#39;r&#39;)  
            plt.scatter(*line, color = &#39;b&#39;)  
    #调整原点到左上角  
    ax = plt.gca()  
    ax.xaxis.set_ticks_position(&#39;top&#39;)  
    plt.show()  
</code></pre>
</li>
</ul>
<h2 id="train-py解析"><a href="#train-py解析" class="headerlink" title="train.py解析"></a>train.py解析</h2><p>train.py即模型的训练过程，包含采样策略。常规训练流程：加载数据集 -&gt; 设置train_loader -&gt; 网络初始化 -&gt; 设置损失函数 -&gt; 设置优化策略 -&gt; 调整网络为训练模式 -&gt; 训练循环。以下列举重点进行分析：  </p>
<ul>
<li><p>train_loader：首先根据batchsize的数值决定调用DenseBoxDataset的<code>__getitem__</code>函数的次数；然后通过<code>collate_fn</code>函数对读取到的batch进一步加工：将读取到的一个batch中的多组数据整合，即增加一个batch维度；最后将batchsize个的batch合并。  </p>
<pre><code>def collate_fn_customer(batch):  
images = []  
bboxes = []  
for i, data in enumerate(batch):  
    # data[0]为img维度  
    images.append(data[0])  
    # data[1]为bbox维度  
    bboxes.append(data[1])  
#对images进行类型转换:list-&gt;torch.tensor  
#注意一张图片中可能有多个bbox，bbox维度不同使用`stack`函数会报错,因此直接返回list形式的bboxes  
images = torch.stack(images)  
batch = (images, bboxes)  
return batch  
</code></pre>
</li>
<li><p>定义网络、损失函数、优化策略，网络和数据需要加载到GPU上，之后设置网络为训练模式：  </p>
<pre><code>os.environ[&#39;CUDA_DEVICE_ORDER&#39;] = &#39;PCI_BUS_ID&#39;  
os.environ[&#39;CUDA_VISIBLE_DEVICES&#39;] = &#39;1&#39;  
device = torch.device(&#39;cuda: 0&#39; if torch.cuda.is_available() else &#39;cpu&#39;)  

net = DenseBox(vgg19=vgg19_pretrain).to(device)  
loss_func = nn.MSELoss(reduce=False).to(device)  
optimizer = torch.optim.SGD(net.parameters(),  
                        lr=base_lr,  
                        momentum=9e-1,  
                        weight_decay=5e-8)  # 5e-4 or 5e-8  

net.train()  
</code></pre>
</li>
<li><p>网络训练过程：从dataloader中以batchsize为单位读取数据，batch中分成两部分：img和GT，img作为网络输入，GT转换成指定形式后，参与后续损失的计算：  </p>
<ol>
<li><p>读取batch[0]存储的imgs数据并加载到GPU上  </p>
</li>
<li><p>读取batch[1]存储的bboxes数据：将bboxes数据转换到与输出特征图尺寸对应的score_map、dist_map上，用于损失计算；将bboxes数据转换到mask_map上，用于应用采样策略。然后将它们加载到GPU上。  </p>
</li>
<li><p>清空梯度-&gt;前向传播-&gt;计算分类和定位损失  </p>
</li>
<li><p>采样策略（以batch_size为单位进行采样，而不是一张图为单位）：  </p>
<pre><code># 统计正样本数量  
pos_indices = torch.nonzero(cls_maps_gt)  
positive_num = pos_indices.size(0)  
# 负样本与正样本相等:img.size(0)即batch_size,若这里使用batch_size会在最后不足一个完整batch时报错  
neg_num = int(float(positive_num) / float(img.size(0)) + 0.5)  
# 获得负样本的mask掩码，用于采负样本  
ones_mask = torch.ones([img.size(0), 1, 60, 60],  
                        dtype=torch.float32).to(device)  
neg_mask = ones_mask - cls_maps_gt  
neg_cls_loss = cls_loss * neg_mask  
# 一半从困难负样本获得,一半随机采样  
half_neg_num = int(neg_num * 0.5 + 0.5)  
neg_cls_loss = neg_cls_loss.view(img.size(0), -1)  
hard_negs, hard_neg_indices = torch.topk(input=neg_cls_loss,  
                                            k=half_neg_num,  
                                            dim=1)  
# 随机采样可改进为从负样本中采样,目前是从全体样本中随机采样  
rand_neg_indices = torch.zeros([img.size(0), half_neg_num], dtype=torch.long).to(device)  
for i in range(img.size(0)):  
    indices = np.random.choice(3600, #60*60  
                                half_neg_num,  
                                replace=False)  
    indices = torch.Tensor(indices)  
    rand_neg_indices[i] = indices  
#汇总负样本indices  
neg_indices = torch.cat((hard_neg_indices,  
                            rand_neg_indices),  
                        dim=1)  
neg_indices = neg_indices.cpu()  
pos_indices = pos_indices.cpu()  
</code></pre>
<p> 这样正负样本点就确定了。  </p>
</li>
<li><p>将上述一维空间的样本idx转换到(batchsize, 1, w, h)坐标空间中，更新mask_map；然后通过grayzone去除掉bbox边缘的一部分正样本，更新mask_map;最终确定全部采样点。  </p>
</li>
<li><p>最后将mask_map与损失map相点乘，即可得到最终的损失：  </p>
<pre><code>mask_cls_loss = mask_maps * cls_loss    #分类损失  
mask_bbox_loc_loss = mask_maps * cls_maps_gt * bbox_loc_loss    #定位损失  
full_loss = lambda_cls * (torch.sum(mask_cls_loss)  
            + lambda_loc * torch.sum(mask_bbox_loc_loss))  
</code></pre>
</li>
<li><p>反向传播和更新参数：  </p>
<pre><code>full_loss.backward()  
optimizer.step()  
</code></pre>
</li>
<li><p>log信息的输出与保存、log信息的输出与保存、checkpoint的保存（不同频率）。另外学习率可以随着epoch的增加作相应调整：  </p>
<pre><code>def adjust_LR(optimizer, epoch):  
    lr = 1e-9  
    if epoch &lt; 5:  
        lr = 1e-9  
    elif epoch &gt;= 5 and epoch &lt; 10:  
        lr = 2e-9  
    elif epoch &gt;= 10 and epoch &lt; 15:  
        lr = 4e-9  
    else:  
        lr = 1e-9  
    for param_group in optimizer.param_groups:  
        param_group[&#39;lr&#39;] = lr    #更新lr  

    return lr  
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="test-py解析"><a href="#test-py解析" class="headerlink" title="test.py解析"></a>test.py解析</h2><p>test.py即模型测试过程：<br>初始化网络并加载到GPU-&gt;网络切换到测试模式-&gt;读取测试图片并做相应变换-&gt;数据输入网络得到输出-&gt;解析输出并可视化（目前未实现统计评估的功能）。以下列举重点并分析：  </p>
<ul>
<li>初始化网络：首先加载vgg19预训练模型，然后使用vgg19初始化DenseBox网络，最后将保存的检查点加载到DenseBox网络。  <pre><code>vgg19_pretrain = torchvision.models.vgg19()  
vgg19_pretrain.load_state_dict(torch.load(&#39;vgg19.pth&#39;))  
net = DenseBox(vgg19=vgg19_pretrain).to(device)  
net.load_state_dict(torch.load(resume))  
print(&#39;=&gt; 网络从 &#123;&#125; 加载&#39;.format(resume))  
</code></pre>
</li>
<li>使用visdom观察预测结果置信度热图：  <pre><code>import visdom  
vis = visdom.Visdom()  
vis.heatmap(score_out[0,0])  
</code></pre>
</li>
<li>解析输出后使用非极大抑制算法，最后训练阶段编写的<code>show</code>函数可视化结果：  <pre><code>#保留置信度前K的结果，并且解析成bbox形式返回  
dets = parse_out_MN(score_map=score_out.cpu(),  
                            loc_map=loc_out.cpu(),  
                            M=H,  
                            N=W,  
                            K=10)  
# 非极大抑制  
keep = NMS(dets=dets, nms_thresh=0.4)  
dets = dets[keep]  
# 可视化结果(GT+DT)  
show(img_tensor, [[60,101,181,143]])  
show(img_tensor, dets)  
</code></pre>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次复现的本质是从头到尾细致地读了一遍代码。收获最大的地方是对数据采样这个方面，有了细致的了解。<br>网络和代码目前可以改进的地方很多：  </p>
<ol>
<li>不支持多尺度，可以结合FPN做改进  </li>
<li>数据加载耗时长，可以考虑多个batch_size的数据批量加载到内存  </li>
<li>测试时的dataloader未完成  </li>
<li>evaluate功能未实现  </li>
<li>细节处可以改进<br>DenseBox代码复现告一段落，之后有时间可能会优化代码。接下来更多着重在mmdetection toolbox上，它的整个框架结构更加成熟，并且也更加高效，值得深入研究。  </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kyno.me/2019/08/29/Learning-DenseBox/" data-id="ckkuhxp4400000zt3au3764wh" data-title="DenseBox代码解析" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/05/Writing-Blog-in-GitPage/">Blog in GitPage</a>
          </li>
        
          <li>
            <a href="/2019/08/29/Learning-DenseBox/">DenseBox代码解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Kyno Yang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>